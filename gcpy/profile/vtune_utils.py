#!/usr/bin/env python3
"""
Utilities for reading reports from the Intel VTune profiler.
"""

from glob import glob
import pandas as pd
from gcpy.constants import ENCODING
from gcpy.util import verify_variable_type

LINES_PER_SCREEN = 30


def vtune_read_hotspots_csv(filename, delimiter="\t"):
    """
    Reads a hotspots report (in CSV format) generated by Intel VTune.

    Args
    filename  : str          : Hotspots report in CSV format

    Kwargs
    delimiter : str          : Text separator (default = "\t" aka TAB)

    Returns
    results   : pd.DataFrame : DataFrame with hotspot information
    """
    verify_variable_type(filename, str)

    dframe = pd.read_csv(
        filename,
        delimiter=delimiter,
        skipinitialspace=True,
        engine="c",
        dtype=str,
    )

    if "CPU Time" in dframe.columns:
        dframe  = dframe.rename(columns={"CPU Time": "CPU Time [s]"})

    return dframe

def vtune_ask_user_to_continue_or_quit(
        print_header,
        dframe,
        linecount,
        lines_per_screen,
):
    """
    Ask user if they wish to display more lines of VTune information
    to the screen, or if they wish to quit.

    Args
    print_header     : function     : Function that prints a header line
    dframe           : pd.DataFrame : Object containing output from VTune
    linecount        : int          : Index of the line being displayed
    lines_per_screen : int          : Pause after showing these many lines

    Returns
    do_quit          : bool         : True if user wishes to quit
    """
    if linecount % lines_per_screen == 0:
        result = input("\nHit any key to continue or Q/q to quit >>> ")

        # User wishes to quit
        if "Q" in result or "q" in result:
            return True

        # User wishes to continue
        print("")
        print_header(dframe)
        return False


def vtune_display_hotspots_by_line(
        dframe,
        lines_per_screen=LINES_PER_SCREEN
):
    """
    Displays hotspots identified by VTune by source code line.

    Args
    dframe           : pd.DataFrame : Hotspot information data

    Kwargs
    lines_per_screen : int          : Pause after showing these many lines
    """
    verify_variable_type(dframe, pd.DataFrame)

    def print_header(dframe):
        """
        Internal function that displays the header line
        to be placed atop each column of data.
        """
        col = list(dframe.columns)
        print(f"Rank      {col[0]:<30}  {col[1]:>12}  {col[2]:>20}")

    # Crop the data to necessary columns
    dframe = dframe[["Source File", "Source Line", "CPU Time [s]"]]

    # Print column headers
    print_header(dframe)

    # Return each row of the DataFrame as a tuple
    for row in dframe.itertuples():

        # Print each line
        linecount = row[0] + 1
        cpu = float(row[3])
        display = f"{linecount:<8}  {row[1]:<30}  {row[2]:>12}  {cpu:>20.6f}"
        print(display)

        # After a certain number of lines, ask user if they want to
        # continue or quit.  If quit, then break out of this loop
        # Ask user to continue/quit.  If returns true, exit
        if vtune_ask_user_to_continue_or_quit(
            print_header,
            dframe,
            linecount,
            lines_per_screen
        ):
            break


def vtune_display_hotspots_by_function(
        dframe,
        lines_per_screen=LINES_PER_SCREEN
):
    """
    Displays hotspots identified by VTune by function

    Args
    dframe           : pd.DataFrame : Hotspot information data

    Kwargs
    lines_per_screen : int          : Pause after showing these many lines
    """
    verify_variable_type(dframe, pd.DataFrame)

    def print_header(dframe):
        """
        Internal function that displays the header line
        to be placed atop each column of data.
        """
        col = list(dframe.columns)
        print(f"Rank      {col[0]:<60}  {col[1]:>20}")

    # Crop the data to necessary columns
    dframe = dframe[["Function", "CPU Time [s]"]]

    # Print column headers
    print_header(dframe)

    # Return each row of the DataFrame as a tuple
    for row in dframe.itertuples():

        # Print each line
        linecount = row[0] + 1
        display = f"{linecount:<8}  {row[1]:<60}  {float(row[2]):>20.6f}"
        print(display)

        # After a certain number of lines, ask user if they want to
        # continue or quit.  If quit, then break out of this loop
        # Ask user to continue/quit.  If returns true, exit
        if vtune_ask_user_to_continue_or_quit(
            print_header,
            dframe,
            linecount,
            lines_per_screen
        ):
            break


def vtune_hotspots(
        filename,
        delimiter="\t",,
        lines_per_screen=LINES_PER_SCREEN
):
    """
    Reads a hotspots report (in CSV format) generated by the Intel VTune
    profiler, and calls the proper function to display the results.

    Args
    filename         : str          : Hotspots report in CSV format

    Kwargs
    delimiter        : str          : Text separator (default = "\t" aka TAB)
    lines_per_screen : int          : Pause after showing these many lines
    """
    verify_variable_type(filename, str)

    # Read the first line of the file
    with open(filename, 'r', encoding=ENCODING) as ifile:
        first_line = ifile.readline().strip()

    # Read the date into a DataFrame
    dframe = vtune_read_hotspots_csv(
        filename,
        delimiter=delimiter
    )

    # Filename contains hotspot output by source code line
    if "Source Line" in first_line:
        vtune_display_hotspots_by_line(
            dframe,
            lines_per_screen=lines_per_screen
        )
        return

    # Filename contains hotspot output by functions
    if "Function" in first_line:
        vtune_display_hotspots_by_function(
            dframe,
            lines_per_screen=lines_per_screen
        )


if __name__ == '__main__':

    filename = "hotspots-byline.r000hs.csv"
    #filename = "hotspots.r000hs.csv"
    DFRAME = vtune_hotspots(filename)
